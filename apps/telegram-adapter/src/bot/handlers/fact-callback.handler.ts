import { Injectable, Logger } from '@nestjs/common';
import { Context } from 'telegraf';
import { PkgCoreApiService } from '../../api/pkg-core-api.service';

/**
 * Callback data format for fact conflict resolution (standardized short prefixes):
 * - f_n:<shortId>  ‚Üí Use new fact, deprecate old
 * - f_o:<shortId>  ‚Üí Keep old fact, reject new
 * - f_b:<shortId>  ‚Üí Keep both facts (COEXIST)
 *
 * These prefixes match FACT_CALLBACK_PREFIX from pkg-core.
 */
const FACT_CALLBACK_PREFIX = {
  NEW: 'f_n:',
  OLD: 'f_o:',
  BOTH: 'f_b:',
} as const;

const FACT_CALLBACK_PREFIXES = [
  FACT_CALLBACK_PREFIX.NEW,
  FACT_CALLBACK_PREFIX.OLD,
  FACT_CALLBACK_PREFIX.BOTH,
] as const;

type FactResolution = 'new' | 'old' | 'both';

interface ParsedFactCallback {
  resolution: FactResolution;
  shortId: string;
}

/**
 * Handler for fact conflict callback queries.
 *
 * These callbacks are generated by FactConflictService when a fact conflict
 * requires human resolution. The user sees three buttons:
 * - ‚úÖ –ù–æ–≤—ã–π ‚Üí Use the new fact
 * - ‚ùå –°—Ç–∞—Ä—ã–π ‚Üí Keep the existing fact
 * - üîÄ –û–±–∞ ‚Üí Keep both facts
 */
@Injectable()
export class FactCallbackHandler {
  private readonly logger = new Logger(FactCallbackHandler.name);

  constructor(private readonly pkgCoreApi: PkgCoreApiService) {}

  /**
   * Check if this handler can process the callback
   */
  canHandle(callbackData: string): boolean {
    return FACT_CALLBACK_PREFIXES.some((prefix) => callbackData.startsWith(prefix));
  }

  /**
   * Handle callback query
   */
  async handle(ctx: Context): Promise<void> {
    const callbackQuery = ctx.callbackQuery;
    if (!callbackQuery || !('data' in callbackQuery)) {
      return;
    }

    const callbackData = callbackQuery.data;
    const parsed = this.parseCallback(callbackData);

    if (!parsed) {
      this.logger.warn(`Invalid fact callback data: ${callbackData}`);
      await ctx.answerCbQuery('Invalid callback');
      return;
    }

    const { resolution, shortId } = parsed;

    this.logger.log(`Processing fact conflict resolution: ${resolution} for ${shortId}`);

    try {
      const result = await this.pkgCoreApi.resolveFactConflict(shortId, resolution);

      if (!result.success) {
        await ctx.answerCbQuery(result.error || '–û—à–∏–±–∫–∞');

        // Update message to show error
        await ctx.editMessageText(
          `‚ùå –û—à–∏–±–∫–∞: ${result.error || '–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å'}`,
          { parse_mode: 'HTML' },
        );
        return;
      }

      // Update message based on resolution
      const feedbackMessage = this.getResolutionFeedback(resolution, result.action);
      await ctx.editMessageText(feedbackMessage, { parse_mode: 'HTML' });

      // Answer callback query
      await ctx.answerCbQuery(this.getShortFeedback(resolution));
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger.error(`Failed to resolve fact conflict: ${errorMessage}`, error);

      // Check for "message not modified" error
      if (this.isMessageNotModifiedError(error)) {
        await ctx.answerCbQuery();
        return;
      }

      await ctx.answerCbQuery('–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞');
    }
  }

  /**
   * Parse callback data into resolution and shortId
   */
  private parseCallback(callbackData: string): ParsedFactCallback | null {
    // Map prefix to resolution type
    const prefixToResolution: Record<string, FactResolution> = {
      [FACT_CALLBACK_PREFIX.NEW]: 'new',
      [FACT_CALLBACK_PREFIX.OLD]: 'old',
      [FACT_CALLBACK_PREFIX.BOTH]: 'both',
    };

    for (const prefix of FACT_CALLBACK_PREFIXES) {
      if (callbackData.startsWith(prefix)) {
        const shortId = callbackData.substring(prefix.length);

        if (!shortId) {
          return null;
        }

        return {
          resolution: prefixToResolution[prefix],
          shortId,
        };
      }
    }
    return null;
  }

  /**
   * Get feedback message for the user after resolution
   */
  private getResolutionFeedback(resolution: FactResolution, action?: string): string {
    switch (resolution) {
      case 'new':
        return `‚úÖ <b>–ü—Ä–∏–Ω—è—Ç –Ω–æ–≤—ã–π —Ñ–∞–∫—Ç</b>\n\n–°—Ç–∞—Ä—ã–π —Ñ–∞–∫—Ç –ø–æ–º–µ—á–µ–Ω –∫–∞–∫ —É—Å—Ç–∞—Ä–µ–≤—à–∏–π.`;
      case 'old':
        return `‚úÖ <b>–°–æ—Ö—Ä–∞–Ω—ë–Ω —Å—Ç–∞—Ä—ã–π —Ñ–∞–∫—Ç</b>\n\n–ù–æ–≤—ã–π —Ñ–∞–∫—Ç –æ—Ç–∫–ª–æ–Ω—ë–Ω.`;
      case 'both':
        return `‚úÖ <b>–°–æ—Ö—Ä–∞–Ω–µ–Ω—ã –æ–±–∞ —Ñ–∞–∫—Ç–∞</b>\n\n–û–±–∞ —Ñ–∞–∫—Ç–∞ —Å–æ—Å—É—â–µ—Å—Ç–≤—É—é—Ç –≤ –±–∞–∑–µ.`;
      default:
        return `‚úÖ <b>–ö–æ–Ω—Ñ–ª–∏–∫—Ç —Ä–∞–∑—Ä–µ—à—ë–Ω</b>`;
    }
  }

  /**
   * Get short feedback for answerCbQuery
   */
  private getShortFeedback(resolution: FactResolution): string {
    switch (resolution) {
      case 'new':
        return '‚úÖ –ù–æ–≤—ã–π —Ñ–∞–∫—Ç –ø—Ä–∏–Ω—è—Ç';
      case 'old':
        return '‚úÖ –°—Ç–∞—Ä—ã–π —Ñ–∞–∫—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω';
      case 'both':
        return '‚úÖ –û–±–∞ —Ñ–∞–∫—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã';
      default:
        return '‚úÖ –ì–æ—Ç–æ–≤–æ';
    }
  }

  /**
   * Check if error is "message not modified"
   */
  private isMessageNotModifiedError(error: unknown): boolean {
    if (error instanceof Error) {
      return error.message.includes('message is not modified');
    }
    return false;
  }
}
